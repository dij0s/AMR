# Adaptive Mesh Refinement (AMR)

<picture>
  <source media="(prefers-color-scheme: dark)" srcset="https://i.imgur.com/1b05piP.png">
  <source media="(prefers-color-scheme: light)" srcset="https://i.imgur.com/VCsUWPv.png">
  <img alt="AMR on heat diffusion simulation">
</picture>

## Overview
This project deals with the implementation of an Adaptive Mesh Refinement (AMR) method for the numerical solution of problems.
AMR is a numerical technique that adjusts the mesh resolution based on local problem characteristics to optimize computational resources and obtain accurate solutions.

The main goal of the project is to develop such an algorithm, designed to generate Octree (3D) or Quadtree (2D) mesh based on a time-varying physical field and a specified indicator.

The following image illustrates the Octree and Quadtree data structures used to represent the mesh hierarchy:

<picture>
  <source media="(prefers-color-scheme: dark)" srcset="https://i.imgur.com/R5vG6YS.png">
  <source media="(prefers-color-scheme: light)" srcset="https://i.imgur.com/EKKGv5w.png">
  <img alt="Quadtree and Octree datastructures">
</picture>

The algorithm will dynamically refine or coarsen the mesh by analyzing changes in the physical field.

The algorithm is then applied to solve a continuous heat transfer problem, in two dimensions, and observe the behavior of the mesh as the solution evolves over time.
The results are validated by comparing them with a reference solution obtained using a uniform mesh.

The following sections provide a detailed overview of the project.

*Please see the [Running the project](#running-the-project) section below for running instructions.*

## Author & Acknowledgments
[Osmani Dion](mailto:dion.osmani@students.hevs.ch), Author, HES-SO Valais-Wallis Student, Informatique et systèmes de communication (3rd year)

[Desmons Florian](mailto:florian.desmons@hevs.ch), Supervisor, HES-SO Valais-Wallis Lecturer, Informatique et systèmes de communication

## Technical Documentation

The following sections provide a detailed technical overview of the project, including the algorithm description, code architecture and performance considerations.

### Project Structure

Considering the project's structure, the codebase is organized as follows:
```bash
├── output # Output directory for simulation data (vtk files, not versioned)
├── src # Source code directory
├── tests # Source code tests directory
├── README.md # Project documentation
├── thermal_equation.py # Main script for running the heat transfer simulation
├── compare_lineouts.py # Script to compare lineout data (not versioned) from simulations
├── pyproject.toml # Project configuration file
└── uv.lock # Lock file generated by uv
```

### Algorithm Description

The overall *simulation algorithm* can be broken down into the following steps:

1. Initialization:
   - Create the initial uniform mesh based on the domain size and resolution.
   - Assign initial values to the mesh cells based on the initial temperature field.

2. Time Integration:
   - Iterate over time steps until the final time is reached.

3. Solve the Heat Equation:
    - Compute the heat diffusion equation using finite differences.
    - Update the temperature field based on the computed values.

4. Adaptive Mesh Refinement (only done every few iterations):
    - Evaluate the refinement criterium based on the temperature field.
    - Refine or coarsen the mesh based on the previous criterium.

5. Data Export:
    - Save the simulation data for visualization.

The *adaptive mesh refinement algorithm* can be described as follows:

1. Compute the refinement indicator for each cell based on the log-scale temperature gradient.
2. Compare the indicator with a threshold to decide whether to refine or coarsen the cell.
3. Refine the cell and its neighboring cells by splitting it into smaller cells or coarsen it by merging it with neighboring cells.
4. Update the mesh structure and redistribute the temperature values accordingly using a linear interpolation.

### Code Architecture

The `src` directory contains the main source code files:
```bash
├── mesh.py # Mesh class used to represent the computational mesh
├── node.py # Node class used to represent the mesh nodes
├── refinement.py # Refinement class used to define mesh refinement criteria
├── scheme.py # Scheme class used to implement the numerical scheme solver
└── benchmark.py # Benchmark class used to compare simulation data
```

The overall architecture of the codebase is designed to be modular, extensible and efficient, allowing for easy integration of new features and optimization techniques.
Each file is documented with detailed comments and docstrings explaining the purpose of the classes and methods.
The codebase is structured around the following key components:

**Mesh**:
- The `Mesh` class represents the computational mesh and contains methods for mesh initialization, refinement, data storage and much more.
- A `Mesh` instance is defined by its root cell, which is recursively subdivided into smaller cells. This recursive structure defines the mesh hierarchy and implements the Octree/Quadtree data structure.
- The `Mesh` class provides two main methods to initialize the mesh: `uniform`, a static method and `create_root`, a class method. The first one creates a uniform mesh based on the argument-defined resolution (defined throughout the number of cells per dimension, `n`) and domain size, while the latter creates the root cell of the mesh without creating its children.
- The `Mesh` class provides a single mesh refinement endpoint method, `refine`, which is responsible for refining or coarsening the mesh based on the argument-given refinement criteria and depth constraints. The method ensures that modification of the structure does not yield any greater than one level difference. The method evaluates the refinement criteria against the leaf cells of the mesh and, when marked for refinement, refines its neighboring cells before splitting the cell itself. This allows for a *strip-like* refinement pattern that ensures a greater resolution at the boundaries of the refined region. After the refinement process, the refinement criteria is again evaluated on the non-previously refined cells parent cells to evaluate if said parent cells should be coarsened. If they shall be coarsened and their children are not marked for refinement, the parent cell is coarsened and its children are removed from the mesh. The mesh integrity is ensured at any given operation and does not exceed the depth constraints.
- The `Mesh` class provides different *helper* methods designed to offer an easy-of-use API and allow for a better user-experience. The `solve` method applies an argument-given numerical scheme to the mesh, the `inject` method applies a function to the mesh nodes, the `leafs` and `root` methods return a Generator of the leaf cells and the root cell of the mesh, respectively, and the `save` method exports the mesh data to a VTK file.

These methods strongly rely on the `Node` class, which represents the mesh nodes.

**Node**:
- The `Node` class represents the mesh nodes and contains methods for node initialization, data storage and much more.
- A `Node` instance is defined by its value, its level in the mesh hierarchy, its parent node reference and its relative origin. The origin is set to the top-left corner of the cell and it is relative to the parent cell's origin. Hence, each individual node has its own referential system with children nodes of relative size 1 in any direction.
- The `Node` instance children are stored in a dictionary with keys corresponding to the relative position of the child node in the parent cell. This allows for a quick access to the children nodes and ensures a constant time complexity for the access operation.
- An important, yet subtle implementation detail in the `Node` class is the `__slots__` attribute. This attribute is used to define the class attributes and optimize the memory usage of the class instances. By defining the `__slots__` attribute, the class instances do not store a dictionary of attributes, but rather a tuple of values. This reduces the memory overhead of the class instances and allows for a more efficient memory usage as the number of instances grows.
- The `Node` class provides a `shall_refine` method that evaluates an argument-given criteria against the node and ensures that a hypothetical refinement does not lead any greater than one level difference. The `shall_coarsen` method does the same for the coarsening operation.
- The `Node` class provides a `refine` method that is used to split the node into smaller nodes. It is used by the `Mesh` class to refine the mesh structure and assumes that the node is, indeed, marked for refinement, hence the method does not evaluate the refinement criteria. The method creates and stores the children nodes in the node's children dictionary. The method also redistributes the node's value to its children nodes using a linear interpolation using the neighboring nodes' values (of same level or greater). The node's value is then set to the average of its children nodes' values. The `Node` class also provides a `coarsen` method that deletes the children nodes and redistributes the node's value to its parent node. The method is used by the `Mesh` class to coarsen the mesh structure and assumes that the node is, indeed, marked for coarsening, hence the method does not evaluate the refinement criteria.
- The `Node` class provides many *geometrical* and *locality* methods that are extensively used by the project implementation. First, the `absolute_origin` and `absolute_centered_origin` properties recursively compute and return the node's absolute origin and center origin in the global referential system. The `adjacent` method returns the same-referential (common parent) adjacent node given its relative origin in constant time. The `neighbor` method returns the neighboring `Node` instance (when it exists) in an argument-given cardinal direction (defined in the helper `Direction` enumeration class, in the `node.py` file). The neighbor that is, in order, assumed to be an adjacent neighbor, an adjacent neighbor of the parent and finally a child of the parent's adjacent neighbor (in the mirrored direction of that we are searching for). The `buffer` method returns a list of nodes that are within a buffer distance of the node. The buffer distance is defined as the argument-given distance and is assumed to be unit-less. Hence, the distance is assumed to be a number of nodes in any given direction and of whatever level. This method also makes use of the `chain` method that eases the access of neighboring nodes in diagonal directions by chaining the `neighbor` method calls. These different methods are all implemented to ensure a constant time complexity as they are critical in every step of the mesh refinement process. This time complexity is enabled by storing the parent reference and children references in the `Node` instances and by using the relative origin to access the children nodes. In reality, the Python dictionnary access operation is of constant **average** time complexity and may only be linear if the hash function leads to many collisions. However, the low number of keys in the children dictionary ensures a low probability of collision and a constant time complexity in practice.
- The `Node` class also provides different helper methods and properties which are used in the `Mesh` class.

These methods are implemented to both handle 2D and 3D meshes and hence support the Octree and Quadtree data structures and its associated operations.


**Refinement**:
- The `RefinementCriterium` class represents the refinement criteria. It contains an abstract method, `eval`, that must be implemented by subclasses to define the refinement criteria logic and a helper static method `handle_neighbor` further used in gradient computation due to the interpolation need.
- A concrete implementation of the `RefinementCriterium` class is provided with the `CustomRefinementCriterium` class. A custom function that is evaluated against a `Node` instance is provided to the class constructor and is used in the `eval` method to evaluate the refinement criteria. The `CustomRefinementCriterium` class is used in the project to quickly define a refinement criteria based on a custom function or bypass the refinement criterium, as done in the stripe-neighboring nodes refinement process.
- The `GradientRefinementCriterium` implements a concrete implementation of the `RefinementCriterium` class. It implements a first-order two-dimensional gradient approximation using the interpolated neighboring nodes' values. Its scaled magnitude is then evaluated against a user-defined threshold to determine if said node shall be refined. A similar concrete implementation class `LogScaleGradientRefinementCriterium` is also provided to evaluate the log-scale gradient against a user-defined threshold. The log-scale allows for a greater sensitivity to small values and a better representation of the gradient's magnitude. It is used in the project to define a refinement criteria based on the temperature gradient of the heat diffusion problem.

This abstract class is used to define the refinement criteria and allows for a flexible and extensible implementation of different criteria based on the user's needs.
This implementation, though, lacks support for 3D meshes and the Octree data structure due to the two-dimensional gradient calculation. It is, however, easily extensible to support 3D meshes and the Octree data structure by implementing the `eval` method and the helper methods accordingly.


**Scheme**:
- The `NumericalScheme` class represents the numerical scheme solver and contains an `apply` method that must be implemented by subclasses to define the numerical scheme logic that is applied to an argument-given list of nodes.
- A concrete implementation of the `NumericalScheme` class is provided with the `SecondOrderCenteredFiniteDifferences` class. It implements a second-order centered finite differences scheme and Neumann boundaries as the domain is assumed to be conservative. The scheme is applied to the mesh nodes in the `Mesh` class to compute the temperature field at the next time step in the `solve` method.

This abstract class is used to define the numerical scheme and allows for a flexible and extensible implementation of different numerical schemes based on the user's needs.
This implementation sadly lacks support for 3D meshes and the Octree data structure due to the two-dimensional gradient calculation. It is, however, easily extensible to support 3D meshes and the Octree data structure by implementing the `apply` method accordingly.


**Benchmark**:
- The `Benchmark` class represents the benchmarking tool and contains methods that help measure the performance of the simulation, in time and memory usage.
- The `Benchmark` class is implemented as a singleton class as it allows for a single instance to be used throughout the project and ensures consistent benchmarking results for individual functions or methods.
- The `Benchmark` class provides different decorators for different needs. The `repeat` decorator repeats the decorated function a user-defined number of times. The `time` decorator measures the execution time of the decorated function and, finally, the `memory` decorator measures the memory usage of the decorated function.
- The benchmarking can be reset at any given time using the corresponding method `reset` and the results of the benchmarking are stored in a dictionary and can be displayed in a human-readable format using the `display` method.

This class is used to measure the performance of the simulation and allows for a quick and easy way to compare different implementations or configurations.


### Performance
- Complexity analysis
- Benchmarks
- Optimization techniques used

## Examples & Usage
- Detailed code examples
- Common use cases
- Parameter configurations
- Best practices

## Results
- Validation results
- Performance metrics
- Visualization of example outputs
- Comparison with other methods (if applicable)

## Running the project
The project has been developed in Python using [uv](https://astral.sh/blog/uv), an extremely fast Python package installer and resolver, written in Rust, and designed as a drop-in-replacement for pip and pip-tools workflows.

I recommend using `uv` to run the project as it allows for a fully reproducible environment. To install `uv`, follow the instructions on the [official website](https://docs.astral.sh/uv/getting-started/installation/#installation-methods).

After installing `uv`, you can simply run the project using the following command, at the root of the project directory:

```bash
uv run thermal_equation.py
```

This will execute the main script of the project used to solve the heat transfer problem.

One can also provide an extra argument to the script to specify the number of iterations to run:

```bash
uv run thermal_equation.py 10 # Run for 10 iterations
```

It provides an easy way to run a simulation multiple times which can be useful for testing and validation purposes.

### Modifying the simulation

If you are willing to modify the physical field, the physical properties or the refinement criterium, you can do so by editing the `thermal_equation.py` script.
Here is an example of the physical properties and mesh/simulation parameters that can be modified:

```python
# adaptive mesh refinement
MIN_RELATIVE_DEPTH: int = -3  # minimum depth of the tree (relative to the base cell)
MAX_RELATIVE_DEPTH: int = 2  # maximum depth of the tree (relative to the base cell)

# spatial
N: int = 64  # number of cells per dimension
LX: float = 10.0  # length of the domain in x [m]
LY: float = 10.0  # length of the domain in y [m]

# temporal
T: float = 100.0  # total simulation time [s]
DT: float = 0.01  # time step [s]

N_RECORDS: int = 200  # number of records to save

# material
RHO: float = 0.06  # density [kg/m^3]
CP: float = 204.0  # specific heat capacity [J/kg/K]
LAMBDA: float = 1.026  # thermal conductivity [W/m/K]
```

### Running the benchmark
A preset of lineout Curve2D VisIt export folders are available in the `export/` directory. You can run the tests using the following command:

```bash
uv run compare_lineouts.py <reference_folder/path> <comparison_folder/path>
```

The order in which the folders are specified matters as the first folder is assumed to be the reference simulation data against which we compare another simulation's data.

## License
This project is licensed under the Creative Commons Attribution 4.0 International License (CC BY 4.0). You are free to:

- Share — copy and redistribute the material in any medium, format, or channel
- Adapt — remix, transform, and build upon the material for any purpose, even commercially
- Under the condition that you give appropriate credit to the author(s), provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the author(s) endorses you or your use.

You can view the full license details at: [Creative Commons Attribution 4.0 International License](https://creativecommons.org/licenses/by/4.0/)


## References

I wish to thank my supervisor, Florian Desmons, for his guidance and support throughout the project. His expertise and insights have been invaluable in the development of the algorithm and the implementation of the simulation.
Moreover, I made use of the following resources to deepen my understanding of the subject and develop the project:

**Berger, M. J., & Colella, P.** (1989). *Local adaptive mesh refinement for shock hydrodynamics*. *Journal of Computational Physics*, 82(1), 64–84. [DOI: 10.1016/0021-9991(89)90035-1](https://doi.org/10.1016/0021-9991(89)90035-1)

**Neumann boundary condition**. (2022). In *Wikipedia*. [Link](https://en.wikipedia.org/w/index.php?title=Neumann_boundary_condition&oldid=1078491049)

**Popinet, S.** (2000). *Stabilité et formation de jets dans les bulles cavitantes* [PhD thesis, Université Pierre et Marie Curie]. [Link](https://hal.science/tel-01460748)

**Popinet, S.** (2003). *Gerris: a tree-based adaptive solver for the incompressible Euler equations in complex geometries*. *Journal of Computational Physics*, 190(2), 572–600. [DOI: 10.1016/S0021-9991(03)00298-5](https://doi.org/10.1016/S0021-9991(03)00298-5)

**Truncation error (numerical integration)**. (2022). In *Wikipedia*. [Link](https://en.wikipedia.org/w/index.php?title=Truncation_error_(numerical_integration)&oldid=1077302811)


The project is an original work developed as part of the HES-SO Valais-Wallis curriculum. Please note that it is intended for educational purposes only and should not be used for commercial or production purposes without proper validation and testing.
If you have any questions or need further information, please feel free to contact me at [dion(dot)osmani(at)students(dot)hevs(dot)ch](mailto:dion.osmani@students.hevs.ch).
